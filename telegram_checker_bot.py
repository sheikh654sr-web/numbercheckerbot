import asyncio
import logging
import re
import os
from typing import List, Tuple
from datetime import datetime, timedelta
import phonenumbers
from phonenumbers import NumberParseException, PhoneNumberFormat
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
from telethon import TelegramClient
from telethon.errors import PhoneNumberInvalidError, UsernameNotOccupiedError
from telethon.tl.functions.contacts import ResolveUsernameRequest
from dotenv import load_dotenv

# Optional Supabase import
try:
    from supabase import create_client, Client
    SUPABASE_AVAILABLE = True
except ImportError:
    SUPABASE_AVAILABLE = False
    Client = None
    create_client = None

# Load environment variables
load_dotenv()

# Bot configuration from environment
BOT_TOKEN = os.getenv("BOT_TOKEN", "8453861160:AAFmViauReZNPveHnEslkOthMwcK6FrIEvI")
API_ID = os.getenv("TELEGRAM_API_ID", "22969300")
API_HASH = os.getenv("TELEGRAM_API_HASH", "e78b8ed26aa341bd36690bdc13d2159a")

# Admin configuration
ADMIN_USER_ID = int(os.getenv("ADMIN_USER_ID", "7325836764"))
ADMIN_USERNAME = os.getenv("ADMIN_USERNAME", "tasktreasur_support")

# Supabase configuration
SUPABASE_URL = os.getenv("SUPABASE_URL", "https://qxaenszcuxyleqjfdene.supabase.co")
SUPABASE_KEY = os.getenv("SUPABASE_KEY", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF4YWVuc3pjdXh5bGVxamZkZW5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxNDg1NDMsImV4cCI6MjA3MTcyNDU0M30.7YQHmClhIq2DEvBkGi3yueTSZ1Q0PTPhBnaHlSENLfg")

# Server configuration
PORT = int(os.getenv("PORT", "10000"))

# Set up logging first
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Initialize Supabase client (optional)
supabase = None
if SUPABASE_AVAILABLE and SUPABASE_URL and SUPABASE_KEY and SUPABASE_URL != "your_supabase_url":
    try:
        # Simple Supabase initialization
        supabase = create_client(SUPABASE_URL, SUPABASE_KEY)
        logger.info("Supabase client initialized successfully")
    except Exception as e:
        logger.warning(f"Supabase not available: {e}")
        logger.info("Using in-memory storage (recommended for initial deployment)")
        supabase = None
else:
    logger.info("Using in-memory storage (Supabase not configured)")

# In-memory storage fallback
memory_users = {}  # user_id: {'language': 'en', 'access_status': 'pending'}
memory_requests = {}  # user_id: {'status': 'pending', 'created_at': datetime}

# Language configurations
LANGUAGES = {
    'en': {
        'name': 'ЁЯЗ║ЁЯЗ╕ English',
        'welcome': """ЁЯУ▒ Telegram Number Checker Bot

Send any phone numbers from any country, I'll check Telegram User IDs for you.

ЁЯОп How it works:
- Send any phone numbers (as many as you want)
- ЁЯЯб Yellow = Found on Telegram (with User ID)
- тЪл Black = Not found on Telegram

Examples:
+8801712345678
01712345678
1234567890
+971501234567

тЪая╕П For educational purposes only.""",
        'help': """ЁЯЖШ Help

ЁЯУ▒ How to use:
1. Send any phone numbers
2. Send multiple numbers at once
3. One number per line

ЁЯУК Results:
ЁЯЯб Yellow = Found on Telegram (with User ID)
тЪл Black = Not found on Telegram

ЁЯУ▒ Any format works:
+8801712345678
01712345678  
1234567890
+971501234567

тЪая╕П For educational purposes only.""",
        'processing': "ЁЯФН Checking {} numbers...",
        'results': "ЁЯУК Results ({} numbers):",
        'summary': "ЁЯУИ Summary:",
        'found': "ЁЯЯб Found: {} numbers",
        'not_found': "тЪл Not found: {} numbers",
        'no_numbers': "тЭМ No numbers found.",
        'invalid_numbers': "тЭМ No valid phone numbers found.",
        'api_error': "тЭМ API credentials not set.",
        'check_error': "тЭМ Error occurred while checking.",
        'language_selection': "ЁЯМР Choose your language:",
        'language_set': "тЬЕ Language set to English",
        'menu_check': "ЁЯУ▒ Check Numbers",
        'menu_help': "ЁЯЖШ Help",
        'menu_language': "ЁЯМР Language",
        'menu_about': "тД╣я╕П About",
        'menu_request': "ЁЯУи Request Access",
        'menu_contact': "ЁЯСитАНЁЯТ╗ Contact Admin",
        'request_sent': "тЬЕ Request sent to admin. Please wait for approval.",
        'request_pending': "тП│ You already have a pending request. Please wait.",
        'request_cooldown': "тП░ Please wait {} hours before sending another request.",
        'access_approved': "тЬЕ Your access has been approved! You can now use the bot.",
        'access_rejected': "тЭМ Your access request has been rejected.",
        'contact_admin': "ЁЯСитАНЁЯТ╗ Contact Admin: @{}",
        'admin_new_request': "ЁЯФФ New Access Request\n\nUser: {} ({})\nUser ID: {}\nLanguage: {}",
        'admin_approve': "тЬЕ Approve",
        'admin_reject': "тЭМ Reject",
        'access_required': "ЁЯФТ You need admin approval to use this bot.\nPlease request access first.",
        'phone_checking_disabled': "ЁЯУ▒ Phone checking feature is currently disabled for deployment.\n\nтЬЕ Bot is working perfectly for other features!\n\nЁЯФз Admin can enable phone checking later with proper setup."
    },
    'bn': {
        'name': 'ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛',
        'welcome': """ЁЯУ▒ ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржирж╛ржорзНржмрж╛рж░ ржЪрзЗржХрж╛рж░ ржмржЯ

ржпрзЗ ржХрзЛржи ржжрзЗрж╢рзЗрж░ ржлрзЛржи ржирж╛ржорзНржмрж╛рж░ ржжрж┐ржи, ржЖржорж┐ ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо User ID ржЪрзЗржХ ржХрж░рзЗ ржжрзЗржЦрж╛ржмрзЛред

ЁЯОп ржХрж┐ржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ:
- ржпрзЗ ржХрзЛржи ржлрзЛржи ржирж╛ржорзНржмрж╛рж░ ржкрж╛ржарж╛ржи (ржпржд ржЦрзБрж╢рж┐)
- ЁЯЯб рж╣рж▓рзБржж = ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржорзЗ ржЖржЫрзЗ (User ID рж╕рж╣)
- тЪл ржХрж╛рж▓рзЛ = ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржорзЗ ржирзЗржЗ

ржЙржжрж╛рж╣рж░ржг:
+8801712345678
01712345678
1234567890
+971501234567

тЪая╕П рж╢рзБржзрзБржорж╛рждрзНрж░ рж╢рж┐ржХрзНрж╖рж╛ржорзВрж▓ржХ ржЙржжрзНржжрзЗрж╢рзНржпрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред""",
        'help': """ЁЯЖШ рж╕рж╛рж╣рж╛ржпрзНржп

ЁЯУ▒ ржХрж┐ржнрж╛ржмрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗржи:
1. ржпрзЗ ржХрзЛржи ржлрзЛржи ржирж╛ржорзНржмрж╛рж░ ржкрж╛ржарж╛ржи
2. ржПржХрж╕рж╛ржерзЗ ржЕржирзЗржХ ржирж╛ржорзНржмрж╛рж░ ржжрж┐рждрзЗ ржкрж╛рж░рзЗржи
3. ржкрзНрж░рждрж┐ рж▓рж╛ржЗржирзЗ ржПржХржЯрж┐ ржирж╛ржорзНржмрж╛рж░

ЁЯУК рж░рзЗржЬрж╛рж▓рзНржЯ:
ЁЯЯб рж╣рж▓рзБржж = ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржорзЗ ржЖржЫрзЗ (User ID рж╕рж╣)
тЪл ржХрж╛рж▓рзЛ = ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржорзЗ ржирзЗржЗ

ЁЯУ▒ ржпрзЗ ржХрзЛржи ржлрж░ржорзНржпрж╛ржЯ:
+8801712345678
01712345678  
1234567890
+971501234567

тЪая╕П рж╢рзБржзрзБржорж╛рждрзНрж░ рж╢рж┐ржХрзНрж╖рж╛ржорзВрж▓ржХ ржЙржжрзНржжрзЗрж╢рзНржпрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред""",
        'processing': "ЁЯФН {}ржЯрж┐ ржирж╛ржорзНржмрж╛рж░ ржЪрзЗржХ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...",
        'results': "ЁЯУК рж░рзЗржЬрж╛рж▓рзНржЯ ({}ржЯрж┐ ржирж╛ржорзНржмрж╛рж░):",
        'summary': "ЁЯУИ рж╕рж╛ржорж╛рж░рж┐:",
        'found': "ЁЯЯб ржкрж╛ржУржпрж╝рж╛ ржЧрзЗржЫрзЗ: {}ржЯрж┐",
        'not_found': "тЪл ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐: {}ржЯрж┐",
        'no_numbers': "тЭМ ржХрзЛржи ржирж╛ржорзНржмрж╛рж░ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред",
        'invalid_numbers': "тЭМ ржмрзИржз ржлрзЛржи ржирж╛ржорзНржмрж╛рж░ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред",
        'api_error': "тЭМ API credentials рж╕рзЗржЯ ржХрж░рж╛ рж╣ржпрж╝ржирж┐ред",
        'check_error': "тЭМ ржЪрзЗржХ ржХрж░рждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣ржпрж╝рзЗржЫрзЗред",
        'language_selection': "ЁЯМР ржЖржкржирж╛рж░ ржнрж╛рж╖рж╛ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзБржи:",
        'language_set': "тЬЕ ржнрж╛рж╖рж╛ ржмрж╛ржВрж▓рж╛ржпрж╝ рж╕рзЗржЯ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ",
        'menu_check': "ЁЯУ▒ ржирж╛ржорзНржмрж╛рж░ ржЪрзЗржХ",
        'menu_help': "ЁЯЖШ рж╕рж╛рж╣рж╛ржпрзНржп",
        'menu_language': "ЁЯМР ржнрж╛рж╖рж╛",
        'menu_about': "тД╣я╕П рж╕ржорзНржкрж░рзНржХрзЗ",
        'menu_request': "ЁЯУи ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ рж░рж┐ржХрзЛржпрж╝рзЗрж╕рзНржЯ",
        'menu_contact': "ЁЯСитАНЁЯТ╗ ржПржбржорж┐ржирзЗрж░ рж╕рж╛ржерзЗ ржпрзЛржЧрж╛ржпрзЛржЧ",
        'request_sent': "тЬЕ ржПржбржорж┐ржирзЗрж░ ржХрж╛ржЫрзЗ рж░рж┐ржХрзЛржпрж╝рзЗрж╕рзНржЯ ржкрж╛ржарж╛ржирзЛ рж╣ржпрж╝рзЗржЫрзЗред ржЕржирзБржорзЛржжржирзЗрж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзБржиред",
        'request_pending': "тП│ ржЖржкржирж╛рж░ ржЗрждрж┐ржоржзрзНржпрзЗ ржПржХржЯрж┐ рж░рж┐ржХрзЛржпрж╝рзЗрж╕рзНржЯ ржкрзЗржирзНржбрж┐ржВ ржЖржЫрзЗред ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзБржиред",
        'request_cooldown': "тП░ ржЖрж░рзЗржХржЯрж┐ рж░рж┐ржХрзЛржпрж╝рзЗрж╕рзНржЯ ржкрж╛ржарж╛ржирзЛрж░ ржЖржЧрзЗ {} ржШржирзНржЯрж╛ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзБржиред",
        'access_approved': "тЬЕ ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржЕржирзБржорзЛржжрж┐ржд рж╣ржпрж╝рзЗржЫрзЗ! ржПржЦржи ржЖржкржирж┐ ржмржЯ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░рзЗржиред",
        'access_rejected': "тЭМ ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ рж░рж┐ржХрзЛржпрж╝рзЗрж╕рзНржЯ ржкрзНрж░рждрзНржпрж╛ржЦрзНржпрж╛ржи ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред",
        'contact_admin': "ЁЯСитАНЁЯТ╗ ржПржбржорж┐ржирзЗрж░ рж╕рж╛ржерзЗ ржпрзЛржЧрж╛ржпрзЛржЧ: @{}",
        'admin_new_request': "ЁЯФФ ржирждрзБржи ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ рж░рж┐ржХрзЛржпрж╝рзЗрж╕рзНржЯ\n\nржЗржЙржЬрж╛рж░: {} ({})\nржЗржЙржЬрж╛рж░ ржЖржЗржбрж┐: {}\nржнрж╛рж╖рж╛: {}",
        'admin_approve': "тЬЕ ржЕржирзБржорзЛржжржи",
        'admin_reject': "тЭМ ржкрзНрж░рждрзНржпрж╛ржЦрзНржпрж╛ржи",
        'access_required': "ЁЯФТ ржПржЗ ржмржЯ ржмрзНржпржмрж╣рж╛рж░рзЗрж░ ржЬржирзНржп ржПржбржорж┐ржирзЗрж░ ржЕржирзБржорзЛржжржи ржкрзНрж░ржпрж╝рзЛржЬржиред\nржжржпрж╝рж╛ ржХрж░рзЗ ржкрзНрж░ржержорзЗ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ рж░рж┐ржХрзЛржпрж╝рзЗрж╕рзНржЯ ржХрж░рзБржиред",
        'phone_checking_disabled': "ЁЯУ▒ ржлрзЛржи ржЪрзЗржХрж┐ржВ ржлрж┐ржЪрж╛рж░ ржмрж░рзНрждржорж╛ржирзЗ deployment ржПрж░ ржЬржирзНржп ржмржирзНржз рж░ржпрж╝рзЗржЫрзЗред\n\nтЬЕ ржмржЯрзЗрж░ ржЕржирзНржпрж╛ржирзНржп ржлрж┐ржЪрж╛рж░ perfectly ржХрж╛ржЬ ржХрж░ржЫрзЗ!\n\nЁЯФз ржПржбржорж┐ржи ржкрж░рзЗ proper setup ржжрж┐ржпрж╝рзЗ ржлрзЛржи ржЪрзЗржХрж┐ржВ ржЪрж╛рж▓рзБ ржХрж░рждрзЗ ржкрж╛рж░ржмрзЗржиред"
    },
    'hi': {
        'name': 'ЁЯЗоЁЯЗ│ рд╣рд┐рдВрджреА',
        'welcome': """ЁЯУ▒ рдЯреЗрд▓реАрдЧреНрд░рд╛рдо рдирдВрдмрд░ рдЪреЗрдХрд░ рдмреЙрдЯ

рдХрд┐рд╕реА рднреА рджреЗрд╢ рдХреЗ рдлреЛрди рдирдВрдмрд░ рднреЗрдЬреЗрдВ, рдореИрдВ рдЯреЗрд▓реАрдЧреНрд░рд╛рдо User ID рдЪреЗрдХ рдХрд░ рджреВрдВрдЧрд╛ред

ЁЯОп рдХреИрд╕реЗ рдХрд╛рдо рдХрд░рддрд╛ рд╣реИ:
- рдХреЛрдИ рднреА рдлреЛрди рдирдВрдмрд░ рднреЗрдЬреЗрдВ (рдЬрд┐рддрдиреЗ рдЪрд╛рд╣реЗрдВ)
- ЁЯЯб рдкреАрд▓рд╛ = рдЯреЗрд▓реАрдЧреНрд░рд╛рдо рдкрд░ рдорд┐рд▓рд╛ (User ID рдХреЗ рд╕рд╛рде)
- тЪл рдХрд╛рд▓рд╛ = рдЯреЗрд▓реАрдЧреНрд░рд╛рдо рдкрд░ рдирд╣реАрдВ рдорд┐рд▓рд╛

рдЙрджрд╛рд╣рд░рдг:
+8801712345678
01712345678
1234567890
+971501234567

тЪая╕П рдХреЗрд╡рд▓ рд╢реИрдХреНрд╖рдгрд┐рдХ рдЙрджреНрджреЗрд╢реНрдпреЛрдВ рдХреЗ рд▓рд┐рдП рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред""",
        'help': """ЁЯЖШ рд╕рд╣рд╛рдпрддрд╛

ЁЯУ▒ рдЙрдкрдпреЛрдЧ рдХреИрд╕реЗ рдХрд░реЗрдВ:
1. рдХреЛрдИ рднреА рдлреЛрди рдирдВрдмрд░ рднреЗрдЬреЗрдВ
2. рдПрдХ рд╕рд╛рде рдХрдИ рдирдВрдмрд░ рднреЗрдЬ рд╕рдХрддреЗ рд╣реИрдВ
3. рд╣рд░ рд▓рд╛рдЗрди рдореЗрдВ рдПрдХ рдирдВрдмрд░

ЁЯУК рдкрд░рд┐рдгрд╛рдо:
ЁЯЯб рдкреАрд▓рд╛ = рдЯреЗрд▓реАрдЧреНрд░рд╛рдо рдкрд░ рдорд┐рд▓рд╛ (User ID рдХреЗ рд╕рд╛рде)
тЪл рдХрд╛рд▓рд╛ = рдЯреЗрд▓реАрдЧреНрд░рд╛рдо рдкрд░ рдирд╣реАрдВ рдорд┐рд▓рд╛

ЁЯУ▒ рдХреЛрдИ рднреА рдлреЙрд░реНрдореЗрдЯ:
+8801712345678
01712345678  
1234567890
+971501234567

тЪая╕П рдХреЗрд╡рд▓ рд╢реИрдХреНрд╖рдгрд┐рдХ рдЙрджреНрджреЗрд╢реНрдпреЛрдВ рдХреЗ рд▓рд┐рдП рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред""",
        'processing': "ЁЯФН {} рдирдВрдмрд░ рдЪреЗрдХ рдХрд░ рд░рд╣реЗ рд╣реИрдВ...",
        'results': "ЁЯУК рдкрд░рд┐рдгрд╛рдо ({} рдирдВрдмрд░):",
        'summary': "ЁЯУИ рд╕рд╛рд░рд╛рдВрд╢:",
        'found': "ЁЯЯб рдорд┐рд▓реЗ: {} рдирдВрдмрд░",
        'not_found': "тЪл рдирд╣реАрдВ рдорд┐рд▓реЗ: {} рдирдВрдмрд░",
        'no_numbers': "тЭМ рдХреЛрдИ рдирдВрдмрд░ рдирд╣реАрдВ рдорд┐рд▓рд╛ред",
        'invalid_numbers': "тЭМ рдХреЛрдИ рд╡реИрдз рдлреЛрди рдирдВрдмрд░ рдирд╣реАрдВ рдорд┐рд▓рд╛ред",
        'api_error': "тЭМ API credentials рд╕реЗрдЯ рдирд╣реАрдВ рд╣реИрдВред",
        'check_error': "тЭМ рдЪреЗрдХ рдХрд░рдиреЗ рдореЗрдВ рд╕рдорд╕реНрдпрд╛ рд╣реБрдИред",
        'language_selection': "ЁЯМР рдЕрдкрдиреА рднрд╛рд╖рд╛ рдЪреБрдиреЗрдВ:",
        'language_set': "тЬЕ рднрд╛рд╖рд╛ рд╣рд┐рдВрджреА рдореЗрдВ рд╕реЗрдЯ рдХреА рдЧрдИ",
        'menu_check': "ЁЯУ▒ рдирдВрдмрд░ рдЪреЗрдХ",
        'menu_help': "ЁЯЖШ рд╕рд╣рд╛рдпрддрд╛",
        'menu_language': "ЁЯМР рднрд╛рд╖рд╛",
        'menu_about': "тД╣я╕П рдмрд╛рд░реЗ рдореЗрдВ",
        'menu_request': "ЁЯУи рдПрдХреНрд╕реЗрд╕ рд░рд┐рдХреНрд╡реЗрд╕реНрдЯ",
        'menu_contact': "ЁЯСитАНЁЯТ╗ рдПрдбрдорд┐рди рд╕реЗ рд╕рдВрдкрд░реНрдХ",
        'request_sent': "тЬЕ рдПрдбрдорд┐рди рдХреЛ рд░рд┐рдХреНрд╡реЗрд╕реНрдЯ рднреЗрдЬреА рдЧрдИред рдЕрдкреНрд░реВрд╡рд▓ рдХрд╛ рдЗрдВрддрдЬрд╝рд╛рд░ рдХрд░реЗрдВред",
        'request_pending': "тП│ рдЖрдкрдХреА рдкрд╣рд▓реЗ рд╕реЗ рдПрдХ рд░рд┐рдХреНрд╡реЗрд╕реНрдЯ рдкреЗрдВрдбрд┐рдВрдЧ рд╣реИред рдЗрдВрддрдЬрд╝рд╛рд░ рдХрд░реЗрдВред",
        'request_cooldown': "тП░ рджреВрд╕рд░реА рд░рд┐рдХреНрд╡реЗрд╕реНрдЯ рднреЗрдЬрдиреЗ рд╕реЗ рдкрд╣рд▓реЗ {} рдШрдВрдЯреЗ рдЗрдВрддрдЬрд╝рд╛рд░ рдХрд░реЗрдВред",
        'access_approved': "тЬЕ рдЖрдкрдХреА рдПрдХреНрд╕реЗрд╕ рдЕрдкреНрд░реВрд╡ рд╣реЛ рдЧрдИ! рдЕрдм рдЖрдк рдмреЙрдЯ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░ рд╕рдХрддреЗ рд╣реИрдВред",
        'access_rejected': "тЭМ рдЖрдкрдХреА рдПрдХреНрд╕реЗрд╕ рд░рд┐рдХреНрд╡реЗрд╕реНрдЯ рд░рд┐рдЬреЗрдХреНрдЯ рд╣реЛ рдЧрдИред",
        'contact_admin': "ЁЯСитАНЁЯТ╗ рдПрдбрдорд┐рди рд╕реЗ рд╕рдВрдкрд░реНрдХ: @{}",
        'admin_new_request': "ЁЯФФ рдирдИ рдПрдХреНрд╕реЗрд╕ рд░рд┐рдХреНрд╡реЗрд╕реНрдЯ\n\nрдпреВрдЬрд░: {} ({})\nрдпреВрдЬрд░ рдЖрдИрдбреА: {}\nрднрд╛рд╖рд╛: {}",
        'admin_approve': "тЬЕ рдЕрдкреНрд░реВрд╡",
        'admin_reject': "тЭМ рд░рд┐рдЬреЗрдХреНрдЯ",
        'access_required': "ЁЯФТ рдЗрд╕ рдмреЙрдЯ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдПрдбрдорд┐рди рдЕрдкреНрд░реВрд╡рд▓ рдЪрд╛рд╣рд┐рдПред\nрдХреГрдкрдпрд╛ рдкрд╣рд▓реЗ рдПрдХреНрд╕реЗрд╕ рд░рд┐рдХреНрд╡реЗрд╕реНрдЯ рдХрд░реЗрдВред",
        'phone_checking_disabled': "ЁЯУ▒ рдлреЛрди рдЪреЗрдХрд┐рдВрдЧ рдлреАрдЪрд░ рд╡рд░реНрддрдорд╛рди рдореЗрдВ deployment рдХреЗ рд▓рд┐рдП рдмрдВрдж рд╣реИред\n\nтЬЕ рдмреЙрдЯ рдХреЗ рдЕрдиреНрдп features perfectly рдХрд╛рдо рдХрд░ рд░рд╣реЗ рд╣реИрдВ!\n\nЁЯФз Admin рдмрд╛рдж рдореЗрдВ proper setup рдХреЗ рд╕рд╛рде phone checking рдЪрд╛рд▓реВ рдХрд░ рд╕рдХрддреЗ рд╣реИрдВред"
    },
    'ar': {
        'name': 'ЁЯЗ╕ЁЯЗж ╪з┘Д╪╣╪▒╪и┘К╪й',
        'welcome': """ЁЯУ▒ ╪и┘И╪к ┘Б╪н╪╡ ╪г╪▒┘В╪з┘Е ╪з┘Д╪к┘Д┘К╪м╪▒╪з┘Е

╪г╪▒╪│┘Д ╪г┘К ╪г╪▒┘В╪з┘Е ┘З╪з╪к┘Б ┘Е┘Ж ╪г┘К ╪п┘И┘Д╪й╪М ┘И╪│╪г┘В┘И┘Е ╪и┘Б╪н╪╡ ┘Е╪╣╪▒┘Б╪з╪к ╪з┘Д┘Е╪│╪к╪о╪п┘Е┘К┘Ж ┘Б┘К ╪з┘Д╪к┘Д┘К╪м╪▒╪з┘Е.

ЁЯОп ┘Г┘К┘Б ┘К╪╣┘Е┘Д:
- ╪г╪▒╪│┘Д ╪г┘К ╪г╪▒┘В╪з┘Е ┘З╪з╪к┘Б (┘Г┘Е╪з ╪к╪┤╪з╪б)
- ЁЯЯб ╪г╪╡┘Б╪▒ = ┘Е┘И╪м┘И╪п ┘Б┘К ╪з┘Д╪к┘Д┘К╪м╪▒╪з┘Е (┘Е╪╣ ┘Е╪╣╪▒┘Б ╪з┘Д┘Е╪│╪к╪о╪п┘Е)
- тЪл ╪г╪│┘И╪п = ╪║┘К╪▒ ┘Е┘И╪м┘И╪п ┘Б┘К ╪з┘Д╪к┘Д┘К╪м╪▒╪з┘Е

╪г┘Е╪л┘Д╪й:
+8801712345678
01712345678
1234567890
+971501234567

тЪая╕П ┘Д┘Д╪г╪║╪▒╪з╪╢ ╪з┘Д╪к╪╣┘Д┘К┘Е┘К╪й ┘Б┘В╪╖.""",
        'help': """ЁЯЖШ ┘Е╪│╪з╪╣╪п╪й

ЁЯУ▒ ┘Г┘К┘Б┘К╪й ╪з┘Д╪з╪│╪к╪о╪п╪з┘Е:
1. ╪г╪▒╪│┘Д ╪г┘К ╪г╪▒┘В╪з┘Е ┘З╪з╪к┘Б
2. ┘К┘Е┘Г┘Ж┘Г ╪е╪▒╪│╪з┘Д ╪╣╪п╪й ╪г╪▒┘В╪з┘Е ┘Б┘К ┘И┘В╪к ┘И╪з╪н╪п
3. ╪▒┘В┘Е ┘И╪з╪н╪п ┘Б┘К ┘Г┘Д ╪│╪╖╪▒

ЁЯУК ╪з┘Д┘Ж╪к╪з╪ж╪м:
ЁЯЯб ╪г╪╡┘Б╪▒ = ┘Е┘И╪м┘И╪п ┘Б┘К ╪з┘Д╪к┘Д┘К╪м╪▒╪з┘Е (┘Е╪╣ ┘Е╪╣╪▒┘Б ╪з┘Д┘Е╪│╪к╪о╪п┘Е)
тЪл ╪г╪│┘И╪п = ╪║┘К╪▒ ┘Е┘И╪м┘И╪п ┘Б┘К ╪з┘Д╪к┘Д┘К╪м╪▒╪з┘Е

ЁЯУ▒ ╪г┘К ╪к┘Ж╪│┘К┘В:
+8801712345678
01712345678  
1234567890
+971501234567

тЪая╕П ┘Д┘Д╪г╪║╪▒╪з╪╢ ╪з┘Д╪к╪╣┘Д┘К┘Е┘К╪й ┘Б┘В╪╖.""",
        'processing': "ЁЯФН ╪м╪з╪▒┘К ┘Б╪н╪╡ {} ╪▒┘В┘Е...",
        'results': "ЁЯУК ╪з┘Д┘Ж╪к╪з╪ж╪м ({} ╪▒┘В┘Е):",
        'summary': "ЁЯУИ ╪з┘Д┘Е┘Д╪о╪╡:",
        'found': "ЁЯЯб ┘Е┘И╪м┘И╪п: {} ╪▒┘В┘Е",
        'not_found': "тЪл ╪║┘К╪▒ ┘Е┘И╪м┘И╪п: {} ╪▒┘В┘Е",
        'no_numbers': "тЭМ ┘Д┘Е ┘К╪к┘Е ╪з┘Д╪╣╪л┘И╪▒ ╪╣┘Д┘Й ╪г╪▒┘В╪з┘Е.",
        'invalid_numbers': "тЭМ ┘Д┘Е ┘К╪к┘Е ╪з┘Д╪╣╪л┘И╪▒ ╪╣┘Д┘Й ╪г╪▒┘В╪з┘Е ┘З╪з╪к┘Б ╪╡╪н┘К╪н╪й.",
        'api_error': "тЭМ ┘Д┘Е ┘К╪к┘Е ╪к╪╣┘К┘К┘Ж ╪и┘К╪з┘Ж╪з╪к ╪з╪╣╪к┘Е╪з╪п API.",
        'check_error': "тЭМ ╪н╪п╪л ╪о╪╖╪г ╪г╪л┘Ж╪з╪б ╪з┘Д┘Б╪н╪╡.",
        'language_selection': "ЁЯМР ╪з╪о╪к╪▒ ┘Д╪║╪к┘Г:",
        'language_set': "тЬЕ ╪к┘Е ╪к╪╣┘К┘К┘Ж ╪з┘Д┘Д╪║╪й ╪е┘Д┘Й ╪з┘Д╪╣╪▒╪и┘К╪й",
        'menu_check': "ЁЯУ▒ ┘Б╪н╪╡ ╪з┘Д╪г╪▒┘В╪з┘Е",
        'menu_help': "ЁЯЖШ ┘Е╪│╪з╪╣╪п╪й",
        'menu_language': "ЁЯМР ╪з┘Д┘Д╪║╪й",
        'menu_about': "тД╣я╕П ╪н┘И┘Д",
        'menu_request': "ЁЯУи ╪╖┘Д╪и ╪з┘Д┘И╪╡┘И┘Д",
        'menu_contact': "ЁЯСитАНЁЯТ╗ ╪з╪к╪╡╪з┘Д ╪и╪з┘Д┘Е╪п┘К╪▒",
        'request_sent': "тЬЕ ╪к┘Е ╪е╪▒╪│╪з┘Д ╪з┘Д╪╖┘Д╪и ┘Д┘Д┘Е╪п┘К╪▒. ╪з┘Ж╪к╪╕╪▒ ╪з┘Д┘Е┘И╪з┘Б┘В╪й.",
        'request_pending': "тП│ ┘Д╪п┘К┘Г ╪╖┘Д╪и ┘Е╪╣┘Д┘В ╪и╪з┘Д┘Б╪╣┘Д. ╪з┘Ж╪к╪╕╪▒.",
        'request_cooldown': "тП░ ╪з┘Ж╪к╪╕╪▒ {} ╪│╪з╪╣╪з╪к ┘В╪и┘Д ╪е╪▒╪│╪з┘Д ╪╖┘Д╪и ╪в╪о╪▒.",
        'access_approved': "тЬЕ ╪к┘Е╪к ╪з┘Д┘Е┘И╪з┘Б┘В╪й ╪╣┘Д┘Й ┘И╪╡┘И┘Д┘Г! ┘К┘Е┘Г┘Ж┘Г ╪з┘Д╪в┘Ж ╪з╪│╪к╪о╪п╪з┘Е ╪з┘Д╪и┘И╪к.",
        'access_rejected': "тЭМ ╪к┘Е ╪▒┘Б╪╢ ╪╖┘Д╪и ╪з┘Д┘И╪╡┘И┘Д ╪з┘Д╪о╪з╪╡ ╪и┘Г.",
        'contact_admin': "ЁЯСитАНЁЯТ╗ ╪з╪к╪╡╪з┘Д ╪и╪з┘Д┘Е╪п┘К╪▒: @{}",
        'admin_new_request': "ЁЯФФ ╪╖┘Д╪и ┘И╪╡┘И┘Д ╪м╪п┘К╪п\n\n╪з┘Д┘Е╪│╪к╪о╪п┘Е: {} ({})\n┘Е╪╣╪▒┘Б ╪з┘Д┘Е╪│╪к╪о╪п┘Е: {}\n╪з┘Д┘Д╪║╪й: {}",
        'admin_approve': "тЬЕ ┘Е┘И╪з┘Б┘В╪й",
        'admin_reject': "тЭМ ╪▒┘Б╪╢",
        'access_required': "ЁЯФТ ╪к╪н╪к╪з╪м ┘Е┘И╪з┘Б┘В╪й ╪з┘Д┘Е╪п┘К╪▒ ┘Д╪з╪│╪к╪о╪п╪з┘Е ┘З╪░╪з ╪з┘Д╪и┘И╪к.\n┘К╪▒╪м┘Й ╪╖┘Д╪и ╪з┘Д┘И╪╡┘И┘Д ╪г┘И┘Д╪з┘Л.",
        'phone_checking_disabled': "ЁЯУ▒ ┘Е┘К╪▓╪й ┘Б╪н╪╡ ╪з┘Д┘З╪з╪к┘Б ┘Е╪╣╪╖┘Д╪й ╪н╪з┘Д┘К╪з┘Л ┘Д┘Д┘Ж╪┤╪▒.\n\nтЬЕ ╪и╪з┘В┘К ┘Е┘К╪▓╪з╪к ╪з┘Д╪и┘И╪к ╪к╪╣┘Е┘Д ╪и╪┤┘Г┘Д ┘Е╪л╪з┘Д┘К!\n\nЁЯФз ┘К┘Е┘Г┘Ж ┘Д┘Д┘Е╪п┘К╪▒ ╪к┘Б╪╣┘К┘Д ┘Б╪н╪╡ ╪з┘Д┘З╪з╪к┘Б ┘Д╪з╪н┘В╪з┘Л ┘Е╪╣ ╪з┘Д╪е╪╣╪п╪з╪п ╪з┘Д┘Е┘Ж╪з╪│╪и."
    }
}

# Database functions
async def init_database():
    """Initialize database tables"""
    if not supabase:
        logger.error("Supabase client not initialized")
        return
        
    try:
        # Create users table
        supabase.table('users').select('*').limit(1).execute()
    except:
        # Table doesn't exist, create it
        logger.info("Creating database tables...")
    
    try:
        # Create access_requests table
        supabase.table('access_requests').select('*').limit(1).execute()
    except:
        logger.info("Access requests table created")

async def get_user_language(user_id: int) -> str:
    """Get user's preferred language from database or memory"""
    if supabase:
        try:
            result = supabase.table('users').select('language').eq('user_id', user_id).execute()
            if result.data:
                return result.data[0]['language']
        except:
            pass
    
    # Fallback to in-memory storage
    if user_id in memory_users:
        return memory_users[user_id].get('language', 'en')
    
    return 'en'  # Default to English

async def set_user_language(user_id: int, language: str):
    """Set user's preferred language in database or memory"""
    if supabase:
        try:
            # Upsert user language
            supabase.table('users').upsert({
                'user_id': user_id,
                'language': language,
                'updated_at': datetime.now().isoformat()
            }).execute()
        except Exception as e:
            logger.error(f"Error setting user language: {e}")
    
    # Always store in memory as fallback
    if user_id not in memory_users:
        memory_users[user_id] = {}
    memory_users[user_id]['language'] = language

async def check_user_access(user_id: int) -> bool:
    """Check if user has access to the bot"""
    if user_id == ADMIN_USER_ID:
        return True
    
    if supabase:
        try:
            result = supabase.table('users').select('access_status').eq('user_id', user_id).execute()
            if result.data:
                return result.data[0]['access_status'] == 'approved'
        except:
            pass
    
    # Check in-memory storage
    if user_id in memory_users:
        return memory_users[user_id].get('access_status', 'pending') == 'approved'
    
    # For deployment without database, allow access for testing
    if not supabase:
        return True
    
    return False

async def get_pending_request(user_id: int) -> dict:
    """Get user's pending request if any"""
    if not supabase:
        return None
        
    try:
        result = supabase.table('access_requests').select('*').eq('user_id', user_id).eq('status', 'pending').execute()
        if result.data:
            return result.data[0]
    except:
        pass
    return None

async def check_request_cooldown(user_id: int) -> int:
    """Check if user is in cooldown period, returns hours remaining"""
    if not supabase:
        return 0
        
    try:
        result = supabase.table('access_requests').select('created_at').eq('user_id', user_id).order('created_at', desc=True).limit(1).execute()
        if result.data:
            last_request = datetime.fromisoformat(result.data[0]['created_at'].replace('Z', '+00:00'))
            cooldown_end = last_request + timedelta(hours=3)
            if datetime.now() < cooldown_end:
                remaining = cooldown_end - datetime.now()
                return int(remaining.total_seconds() / 3600) + 1
    except:
        pass
    return 0

async def create_access_request(user_id: int, username: str, first_name: str, language: str):
    """Create new access request"""
    if not supabase:
        logger.warning("Supabase not available, request not saved")
        return False
        
    try:
        supabase.table('access_requests').insert({
            'user_id': user_id,
            'username': username,
            'first_name': first_name,
            'language': language,
            'status': 'pending',
            'created_at': datetime.now().isoformat()
        }).execute()
        return True
    except Exception as e:
        logger.error(f"Error creating access request: {e}")
        return False

async def update_access_request(request_id: int, status: str):
    """Update access request status"""
    if not supabase:
        logger.warning("Supabase not available, request status not updated")
        return False
        
    try:
        supabase.table('access_requests').update({
            'status': status,
            'updated_at': datetime.now().isoformat()
        }).eq('id', request_id).execute()
        
        # Also update user access status
        request = supabase.table('access_requests').select('user_id').eq('id', request_id).execute()
        if request.data:
            user_id = request.data[0]['user_id']
            supabase.table('users').upsert({
                'user_id': user_id,
                'access_status': status,
                'updated_at': datetime.now().isoformat()
            }).execute()
        
        return True
    except Exception as e:
        logger.error(f"Error updating access request: {e}")
        return False

async def get_text(user_id: int, key: str) -> str:
    """Get localized text for user"""
    lang = await get_user_language(user_id)
    return LANGUAGES[lang].get(key, LANGUAGES['en'][key])

def get_language_keyboard():
    """Get language selection keyboard"""
    keyboard = []
    for lang_code, lang_data in LANGUAGES.items():
        keyboard.append([KeyboardButton(lang_data['name'])])
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)

async def get_main_menu_keyboard(user_id: int):
    """Get main menu keyboard based on user's language and access status"""
    lang = await get_user_language(user_id)
    texts = LANGUAGES[lang]
    has_access = await check_user_access(user_id)
    
    if has_access:
        keyboard = [
            [KeyboardButton(texts['menu_check']), KeyboardButton(texts['menu_help'])],
            [KeyboardButton(texts['menu_language']), KeyboardButton(texts['menu_about'])]
        ]
    else:
        keyboard = [
            [KeyboardButton(texts['menu_request']), KeyboardButton(texts['menu_contact'])],
            [KeyboardButton(texts['menu_language']), KeyboardButton(texts['menu_help'])]
        ]
    
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

def get_admin_approval_keyboard(request_id: int):
    """Get admin approval/rejection keyboard"""
    keyboard = [
        [
            InlineKeyboardButton("тЬЕ Approve", callback_data=f"approve_{request_id}"),
            InlineKeyboardButton("тЭМ Reject", callback_data=f"reject_{request_id}")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

class TelegramChecker:
    def __init__(self, api_id: str, api_hash: str):
        self.api_id = api_id
        self.api_hash = api_hash
        self.client = None
    
    async def initialize_client(self):
        """Initialize Telethon client"""
        try:
            # Use in-memory session for deployment
            from telethon.sessions import StringSession
            
            # Try to get session string from environment
            session_string = os.getenv('TELETHON_SESSION', '')
            
            if session_string:
                # Use existing session string
                self.client = TelegramClient(StringSession(session_string), self.api_id, self.api_hash)
            else:
                # Use empty session (will require authentication)
                self.client = TelegramClient(StringSession(), self.api_id, self.api_hash)
            
            # Start client without phone verification for deployment
            await self.client.start()
            logger.info("Telethon client initialized successfully")
            
            # Save session string for future use (in logs only)
            if not session_string:
                new_session = self.client.session.save()
                logger.info(f"New session created: {new_session[:20]}...")
            
            return True
        except Exception as e:
            logger.error(f"Failed to initialize Telethon client: {e}")
            logger.warning("Phone checking will be disabled - bot will work without this feature")
            self.client = None
            return False
    
    async def check_phone_numbers(self, phone_numbers: List[str]) -> Tuple[List[dict], List[str]]:
        """Check phone numbers and return user info for existing accounts"""
        existing_with_info = []
        non_existing = []
        
        if not self.client:
            logger.error("Telethon client not initialized")
            return existing_with_info, non_existing
        
        for phone in phone_numbers:
            try:
                # Format phone number
                formatted_phone = self.format_phone_number(phone)
                if not formatted_phone:
                    non_existing.append(phone)
                    continue
                
                logger.info(f"Checking phone number: {formatted_phone}")
                user_info = await self._get_user_info(formatted_phone)
                
                # Add to appropriate list
                if user_info:
                    existing_with_info.append({
                        'phone': phone,
                        'formatted_phone': formatted_phone,
                        'user_id': user_info.get('user_id'),
                        'first_name': user_info.get('first_name', ''),
                        'last_name': user_info.get('last_name', ''),
                        'username': user_info.get('username', '')
                    })
                    logger.info(f"тЬЕ Found user: {formatted_phone} -> ID: {user_info.get('user_id')}")
                else:
                    non_existing.append(phone)
                    logger.info(f"тЭМ Not found: {formatted_phone}")
                    
            except Exception as e:
                logger.error(f"Error checking phone {phone}: {e}")
                non_existing.append(phone)
        
        return existing_with_info, non_existing
    
    async def _get_user_info(self, formatted_phone: str) -> dict:
        """Get user information if phone number exists on Telegram"""
        
        # Method 1: Direct entity lookup
        try:
            entity = await self.client.get_entity(formatted_phone)
            if entity:
                # Check if it's a valid user (not deleted)
                if hasattr(entity, 'deleted') and entity.deleted:
                    logger.debug(f"Account deleted: {formatted_phone}")
                    return None
                
                # Extract user information
                user_info = {
                    'user_id': entity.id,
                    'first_name': getattr(entity, 'first_name', ''),
                    'last_name': getattr(entity, 'last_name', ''),
                    'username': getattr(entity, 'username', ''),
                    'phone': getattr(entity, 'phone', '')
                }
                
                logger.info(f"Found via direct entity: {formatted_phone} -> {user_info}")
                return user_info
                
        except Exception as e:
            error_msg = str(e).lower()
            
            if any(keyword in error_msg for keyword in [
                'no user has', 'user not found', 'phone number invalid',
                'no such user', 'username not occupied', 'phone_number_invalid'
            ]):
                logger.debug(f"Definitely does not exist: {formatted_phone}")
                return None
            else:
                logger.debug(f"Other error for {formatted_phone}: {str(e)}")
        
        # Method 2: Try alternative formats
        alternative_formats = self._get_alternative_formats(formatted_phone)
        
        for alt_format in alternative_formats:
            try:
                entity = await self.client.get_entity(alt_format)
                if entity:
                    if hasattr(entity, 'deleted') and entity.deleted:
                        continue
                    
                    user_info = {
                        'user_id': entity.id,
                        'first_name': getattr(entity, 'first_name', ''),
                        'last_name': getattr(entity, 'last_name', ''),
                        'username': getattr(entity, 'username', ''),
                        'phone': getattr(entity, 'phone', '')
                    }
                    
                    logger.info(f"Found via alt format {alt_format}: {formatted_phone} -> {user_info}")
                    return user_info
                    
            except Exception:
                continue
        
        # Method 3: Contacts import as final check
        try:
            from telethon.tl.functions.contacts import ImportContactsRequest, DeleteContactsRequest
            from telethon.tl.types import InputPhoneContact
            
            import time
            client_id = int(time.time() * 1000) % 2147483647
            
            contact = InputPhoneContact(
                client_id=client_id,
                phone=formatted_phone.replace('+', ''),
                first_name="Check",
                last_name=""
            )
            
            result = await self.client(ImportContactsRequest([contact]))
            
            if result and result.users and len(result.users) > 0:
                user = result.users[0]
                
                if hasattr(user, 'id') and user.id:
                    user_info = {
                        'user_id': user.id,
                        'first_name': getattr(user, 'first_name', ''),
                        'last_name': getattr(user, 'last_name', ''),
                        'username': getattr(user, 'username', ''),
                        'phone': getattr(user, 'phone', '')
                    }
                    
                    # Clean up
                    try:
                        await self.client(DeleteContactsRequest(result.users))
                    except:
                        pass
                    
                    logger.info(f"Found via contacts import: {formatted_phone} -> {user_info}")
                    return user_info
            
            # Clean up even if not found
            try:
                if result and result.users:
                    await self.client(DeleteContactsRequest(result.users))
            except:
                pass
                
        except Exception as e:
            logger.debug(f"Contacts import failed for {formatted_phone}: {str(e)}")
        
        logger.debug(f"No user info found for: {formatted_phone}")
        return None
    
    async def _advanced_phone_check(self, formatted_phone: str) -> bool:
        """Balanced phone checking - accurate but not overly strict"""
        
        # Method 1: Direct entity lookup (most reliable)
        try:
            entity = await self.client.get_entity(formatted_phone)
            if entity:
                # Check if it's a valid user (not bot, not deleted)
                if hasattr(entity, 'deleted') and entity.deleted:
                    logger.debug(f"Account deleted: {formatted_phone}")
                    return False
                
                # Allow bots as they are valid Telegram accounts
                # if hasattr(entity, 'bot') and entity.bot:
                #     logger.debug(f"Is bot account: {formatted_phone}")
                #     return False
                
                # If we got an entity, it means the number exists
                logger.info(f"FOUND via direct entity: {formatted_phone}")
                return True
                
        except Exception as e:
            error_msg = str(e).lower()
            
            # Check for definitive "not found" errors
            if any(keyword in error_msg for keyword in [
                'no user has', 'user not found', 'phone number invalid',
                'no such user', 'username not occupied', 'phone_number_invalid'
            ]):
                logger.debug(f"Definitely does not exist: {formatted_phone}")
                return False
            else:
                logger.debug(f"Other error for {formatted_phone}: {str(e)}")
        
        # Method 2: Try alternative formats
        alternative_formats = self._get_alternative_formats(formatted_phone)
        
        for alt_format in alternative_formats:
            try:
                entity = await self.client.get_entity(alt_format)
                if entity:
                    if hasattr(entity, 'deleted') and entity.deleted:
                        continue
                    
                    logger.info(f"FOUND via alt format {alt_format}: {formatted_phone}")
                    return True
                    
            except Exception as e:
                error_msg = str(e).lower()
                if any(keyword in error_msg for keyword in [
                    'no user has', 'user not found', 'phone number invalid',
                    'no such user', 'username not occupied', 'phone_number_invalid'
                ]):
                    continue  # This format doesn't exist, try next
                else:
                    continue
        
        # Method 3: Try contacts import as final check (but with better validation)
        try:
            from telethon.tl.functions.contacts import ImportContactsRequest, DeleteContactsRequest
            from telethon.tl.types import InputPhoneContact
            
            import time
            client_id = int(time.time() * 1000) % 2147483647
            
            contact = InputPhoneContact(
                client_id=client_id,
                phone=formatted_phone.replace('+', ''),
                first_name="Check",
                last_name=""
            )
            
            result = await self.client(ImportContactsRequest([contact]))
            
            if result and result.users and len(result.users) > 0:
                user = result.users[0]
                
                # More lenient check - if we got a user back, it likely exists
                if hasattr(user, 'id') and user.id:
                    # Clean up
                    try:
                        await self.client(DeleteContactsRequest(result.users))
                    except:
                        pass
                    
                    logger.info(f"FOUND via contacts import: {formatted_phone}")
                    return True
            
            # Clean up even if not found
            try:
                if result and result.users:
                    await self.client(DeleteContactsRequest(result.users))
            except:
                pass
                
        except Exception as e:
            logger.debug(f"Contacts import failed for {formatted_phone}: {str(e)}")
        
        logger.debug(f"NOT FOUND after all methods: {formatted_phone}")
        return False
    
    def _normalize_phone(self, phone: str) -> str:
        """Normalize phone number for comparison"""
        # Remove all non-digits
        digits_only = re.sub(r'\D', '', phone)
        
        # Handle Bangladeshi numbers
        if digits_only.startswith('88'):
            if digits_only.startswith('880'):
                return '+' + digits_only
            else:
                return '+' + digits_only
        elif digits_only.startswith('01') and len(digits_only) == 11:
            return '+88' + digits_only
        else:
            return '+88' + digits_only
    
    def _get_alternative_formats(self, phone: str) -> List[str]:
        """Get alternative phone number formats to try"""
        alternatives = []
        
        # Remove + and get digits
        digits = re.sub(r'\D', '', phone)
        
        if digits.startswith('88'):
            # Try with +88
            alternatives.append('+' + digits)
            
            # Try removing country code
            if digits.startswith('880'):
                alternatives.append('+88' + digits[3:])
                alternatives.append('+880' + digits[3:])
            elif digits.startswith('88') and not digits.startswith('880'):
                alternatives.append('+880' + digits[2:])
        
        # Try with leading zero
        if not any(alt.endswith('0' + digits[-10:]) for alt in alternatives):
            alternatives.append('+8801' + digits[-9:])
        
        # Remove duplicates and original
        alternatives = list(set(alternatives))
        if phone in alternatives:
            alternatives.remove(phone)
            
        return alternatives[:3]  # Limit to 3 alternatives to avoid spam
    
    def format_phone_number(self, phone: str) -> str:
        """Simple phone number formatting - accepts any format"""
        try:
            # Remove any non-digit characters except +
            cleaned = re.sub(r'[^\d+]', '', phone)
            
            # If it already starts with +, return as-is if valid length
            if cleaned.startswith('+'):
                if 8 <= len(cleaned) <= 15 and cleaned[1:].isdigit():
                    return cleaned
            
            # If no +, add it if looks like phone number
            if cleaned.isdigit() and 7 <= len(cleaned) <= 15:
                return '+' + cleaned
            
            # Return original if can't format
            return phone
                
        except Exception as e:
            logger.error(f"Error formatting phone number {phone}: {e}")
            return phone
    


# Initialize checker (will be set up properly when API credentials are provided)
checker = None
application = None

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start command handler with language selection and access control"""
    user_id = update.effective_user.id
    
    # Initialize database on first run
    await init_database()
    
    # Check if user has language set
    current_lang = await get_user_language(user_id)
    if current_lang == 'en' and user_id != ADMIN_USER_ID:
        # New user, show language selection
        await update.message.reply_text(
            "ЁЯМР Welcome! Please choose your language:\n"
            "рж╕рзНржмрж╛ржЧрждржо! ржЖржкржирж╛рж░ ржнрж╛рж╖рж╛ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзБржи:\n"
            "рдирдорд╕реНрддреЗ! рдЕрдкрдиреА рднрд╛рд╖рд╛ рдЪреБрдиреЗрдВ:\n"
            "┘Е╪▒╪н╪и╪з┘Л! ╪з╪о╪к╪▒ ┘Д╪║╪к┘Г:",
            reply_markup=get_language_keyboard()
        )
    else:
        # Show welcome message with appropriate menu
        welcome_text = await get_text(user_id, 'welcome')
        keyboard = await get_main_menu_keyboard(user_id)
        await update.message.reply_text(welcome_text, reply_markup=keyboard)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle all text messages including menu buttons and phone numbers"""
    user_id = update.effective_user.id
    message_text = update.message.text.strip()
    user = update.effective_user
    
    # Handle language selection
    for lang_code, lang_data in LANGUAGES.items():
        if message_text == lang_data['name']:
            await set_user_language(user_id, lang_code)
            welcome_text = await get_text(user_id, 'welcome')
            keyboard = await get_main_menu_keyboard(user_id)
            await update.message.reply_text(
                await get_text(user_id, 'language_set'),
                reply_markup=keyboard
            )
            await update.message.reply_text(welcome_text)
            return
    
    # Handle menu buttons
    lang = await get_user_language(user_id)
    texts = LANGUAGES[lang]
    
    if message_text == texts['menu_help']:
        await help_command(update, context)
        return
    elif message_text == texts['menu_language']:
        await update.message.reply_text(
            await get_text(user_id, 'language_selection'),
            reply_markup=get_language_keyboard()
        )
        return
    elif message_text == texts['menu_request']:
        await handle_access_request(update, context)
        return
    elif message_text == texts['menu_contact']:
        await update.message.reply_text(
            (await get_text(user_id, 'contact_admin')).format(ADMIN_USERNAME)
        )
        return
    elif message_text == texts['menu_about']:
        about_text = f"""тД╣я╕П About

ЁЯУ▒ Telegram Number Checker Bot
ЁЯдЦ Multi-language support
ЁЯМН Works with all countries
ЁЯФН Instant User ID detection

ЁЯЫая╕П Version: 2.0
ЁЯСитАНЁЯТ╗ Advanced phone number checker"""
        
        if lang == 'bn':
            about_text = f"""тД╣я╕П рж╕ржорзНржкрж░рзНржХрзЗ

ЁЯУ▒ ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржирж╛ржорзНржмрж╛рж░ ржЪрзЗржХрж╛рж░ ржмржЯ
ЁЯдЦ ржмрж╣рзБ ржнрж╛рж╖рж╛ рж╕рж╛ржкрзЛрж░рзНржЯ
ЁЯМН рж╕ржм ржжрзЗрж╢рзЗрж░ рж╕рж╛ржерзЗ ржХрж╛ржЬ ржХрж░рзЗ
ЁЯФН рждрж╛рзОржХрзНрж╖ржгрж┐ржХ User ID рж╕ржирж╛ржХрзНрждржХрж░ржг

ЁЯЫая╕П рж╕ржВрж╕рзНржХрж░ржг: 2.0
ЁЯСитАНЁЯТ╗ ржЙржирзНржиржд ржлрзЛржи ржирж╛ржорзНржмрж╛рж░ ржЪрзЗржХрж╛рж░"""
        elif lang == 'hi':
            about_text = f"""тД╣я╕П рдмрд╛рд░реЗ рдореЗрдВ

ЁЯУ▒ рдЯреЗрд▓реАрдЧреНрд░рд╛рдо рдирдВрдмрд░ рдЪреЗрдХрд░ рдмреЙрдЯ
ЁЯдЦ рдмрд╣реБ рднрд╛рд╖рд╛ рд╕рдорд░реНрдерди
ЁЯМН рд╕рднреА рджреЗрд╢реЛрдВ рдХреЗ рд╕рд╛рде рдХрд╛рдо рдХрд░рддрд╛ рд╣реИ
ЁЯФН рддрддреНрдХрд╛рд▓ User ID рдкрд╣рдЪрд╛рди

ЁЯЫая╕П рд╕рдВрд╕реНрдХрд░рдг: 2.0
ЁЯСитАНЁЯТ╗ рдЙрдиреНрдирдд рдлреЛрди рдирдВрдмрд░ рдЪреЗрдХрд░"""
        elif lang == 'ar':
            about_text = f"""тД╣я╕П ╪н┘И┘Д

ЁЯУ▒ ╪и┘И╪к ┘Б╪н╪╡ ╪г╪▒┘В╪з┘Е ╪з┘Д╪к┘Д┘К╪м╪▒╪з┘Е
ЁЯдЦ ╪п╪╣┘Е ┘Е╪к╪╣╪п╪п ╪з┘Д┘Д╪║╪з╪к
ЁЯМН ┘К╪╣┘Е┘Д ┘Е╪╣ ╪м┘Е┘К╪╣ ╪з┘Д╪и┘Д╪п╪з┘Ж
ЁЯФН ┘Г╪┤┘Б ┘Б┘И╪▒┘К ┘Д┘Е╪╣╪▒┘Б ╪з┘Д┘Е╪│╪к╪о╪п┘Е

ЁЯЫая╕П ╪з┘Д╪е╪╡╪п╪з╪▒: 2.0
ЁЯСитАНЁЯТ╗ ┘Б╪з╪н╪╡ ╪г╪▒┘В╪з┘Е ┘З╪з╪к┘Б ┘Е╪к┘В╪п┘Е"""
        
        await update.message.reply_text(about_text)
        return
    elif message_text == texts['menu_check']:
        has_access = await check_user_access(user_id)
        if has_access:
            instruction_text = texts['help']
            await update.message.reply_text(instruction_text)
        else:
            await update.message.reply_text(await get_text(user_id, 'access_required'))
        return
    
    # Handle phone numbers (only if user has access)
    has_access = await check_user_access(user_id)
    if not has_access:
        await update.message.reply_text(await get_text(user_id, 'access_required'))
        return
    
    await check_phone_numbers(update, context)

async def check_phone_numbers(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle phone number checking with localized messages"""
    user_id = update.effective_user.id
    message_text = update.message.text.strip()
    
    if not message_text:
        await update.message.reply_text(await get_text(user_id, 'no_numbers'))
        return
    
    # Extract phone numbers from message
    phone_numbers = []
    lines = message_text.split('\n')
    
    for line in lines:
        line = line.strip()
        if line:
            # Check if line contains phone number pattern
            phone_pattern = r'[\+]?[0-9\s\-\(\)]{7,15}'
            if re.search(phone_pattern, line):
                phone_numbers.append(line)
    
    if not phone_numbers:
        await update.message.reply_text(await get_text(user_id, 'invalid_numbers'))
        return
    
    # Send processing message
    processing_msg = await update.message.reply_text(
        (await get_text(user_id, 'processing')).format(len(phone_numbers))
    )
    
    try:
        if not checker or not checker.client:
            not_available_text = await get_text(user_id, 'phone_checking_disabled')
            await processing_msg.edit_text(not_available_text)
            return
        
        # Check phone numbers
        existing_users, non_existing = await checker.check_phone_numbers(phone_numbers)
        
        # Build single response with color coding
        response = (await get_text(user_id, 'results')).format(len(phone_numbers)) + "\n\n"
        
        # Add existing users with yellow circle
        for user in existing_users:
            response += f"ЁЯЯб {user['phone']} - ID: `{user['user_id']}`\n"
        
        # Add non-existing with black circle
        for phone in non_existing:
            response += f"тЪл {phone}\n"
        
        # Summary at the end
        response += f"\n{await get_text(user_id, 'summary')}\n"
        response += f"{(await get_text(user_id, 'found')).format(len(existing_users))}\n"
        response += f"{(await get_text(user_id, 'not_found')).format(len(non_existing))}"
        
        # Check if response is too long for single message
        if len(response) > 4000:
            # Split into chunks
            chunks = []
            current_chunk = (await get_text(user_id, 'results')).format(len(phone_numbers)) + "\n\n"
            
            # Add existing users
            for user in existing_users:
                line = f"ЁЯЯб {user['phone']} - ID: `{user['user_id']}`\n"
                if len(current_chunk + line) > 3500:
                    chunks.append(current_chunk)
                    current_chunk = line
                else:
                    current_chunk += line
            
            # Add non-existing
            for phone in non_existing:
                line = f"тЪл {phone}\n"
                if len(current_chunk + line) > 3500:
                    chunks.append(current_chunk)
                    current_chunk = line
                else:
                    current_chunk += line
            
            # Add summary to last chunk
            summary = f"\n{await get_text(user_id, 'summary')}\n{(await get_text(user_id, 'found')).format(len(existing_users))}\n{(await get_text(user_id, 'not_found')).format(len(non_existing))}"
            current_chunk += summary
            chunks.append(current_chunk)
            
            # Send first chunk as edit, rest as new messages
            await processing_msg.edit_text(chunks[0], parse_mode='Markdown')
            for chunk in chunks[1:]:
                await update.message.reply_text(chunk, parse_mode='Markdown')
        else:
            await processing_msg.edit_text(response, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Error processing numbers: {e}")
        await processing_msg.edit_text(await get_text(user_id, 'check_error'))

async def handle_access_request(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle access request from user"""
    user_id = update.effective_user.id
    user = update.effective_user
    
    # Check if user already has access
    if await check_user_access(user_id):
        await update.message.reply_text("тЬЕ You already have access to the bot!")
        return
    
    # Check for pending request
    pending = await get_pending_request(user_id)
    if pending:
        await update.message.reply_text(await get_text(user_id, 'request_pending'))
        return
    
    # Check cooldown
    cooldown_hours = await check_request_cooldown(user_id)
    if cooldown_hours > 0:
        await update.message.reply_text(
            (await get_text(user_id, 'request_cooldown')).format(cooldown_hours)
        )
        return
    
    # Create new request
    language = await get_user_language(user_id)
    success = await create_access_request(
        user_id,
        user.username or "No username",
        user.first_name or "No name",
        language
    )
    
    if success:
        # Send notification to admin
        admin_text = LANGUAGES['en']['admin_new_request'].format(
            user.first_name or "No name",
            user.username or "No username",
            user_id,
            LANGUAGES[language]['name']
        )
        
        # Get the request ID for the keyboard
        request = await get_pending_request(user_id)
        if request:
            keyboard = get_admin_approval_keyboard(request['id'])
            await context.bot.send_message(
                chat_id=ADMIN_USER_ID,
                text=admin_text,
                reply_markup=keyboard
            )
        
        await update.message.reply_text(await get_text(user_id, 'request_sent'))
    else:
        await update.message.reply_text("тЭМ Error creating request. Please try again.")

async def handle_admin_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle admin approval/rejection callbacks"""
    query = update.callback_query
    await query.answer()
    
    if query.from_user.id != ADMIN_USER_ID:
        await query.edit_message_text("тЭМ Unauthorized")
        return
    
    data = query.data
    if data.startswith("approve_"):
        request_id = int(data.split("_")[1])
        success = await update_access_request(request_id, "approved")
        
        if success:
            # Get user info to send notification
            try:
                if supabase:
                    request_info = supabase.table('access_requests').select('user_id').eq('id', request_id).execute()
                    if request_info.data:
                        user_id = request_info.data[0]['user_id']
                        await context.bot.send_message(
                            chat_id=user_id,
                            text=await get_text(user_id, 'access_approved')
                        )
                    
                    # Send new keyboard to user
                    keyboard = await get_main_menu_keyboard(user_id)
                    await context.bot.send_message(
                        chat_id=user_id,
                        text="ЁЯОЙ Welcome! You can now use the bot.",
                        reply_markup=keyboard
                    )
            except Exception as e:
                logger.error(f"Error notifying user: {e}")
            
            await query.edit_message_text("тЬЕ Request approved and user notified!")
        else:
            await query.edit_message_text("тЭМ Error approving request")
    
    elif data.startswith("reject_"):
        request_id = int(data.split("_")[1])
        success = await update_access_request(request_id, "rejected")
        
        if success:
            # Get user info to send notification
            try:
                if supabase:
                    request_info = supabase.table('access_requests').select('user_id').eq('id', request_id).execute()
                    if request_info.data:
                        user_id = request_info.data[0]['user_id']
                        await context.bot.send_message(
                            chat_id=user_id,
                            text=await get_text(user_id, 'access_rejected')
                        )
            except Exception as e:
                logger.error(f"Error notifying user: {e}")
            
            await query.edit_message_text("тЭМ Request rejected and user notified!")
        else:
            await query.edit_message_text("тЭМ Error rejecting request")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Help command handler with localized text"""
    user_id = update.effective_user.id
    help_text = await get_text(user_id, 'help')
    await update.message.reply_text(help_text)

async def main():
    """Main function to run the bot"""
    global checker, application
    
    # Initialize checker if API credentials are provided (disabled for deployment)
    checker = None
    if os.getenv('ENABLE_PHONE_CHECKING', '').lower() == 'true':
        if API_ID != "YOUR_API_ID" and API_HASH != "YOUR_API_HASH":
            checker = TelegramChecker(API_ID, API_HASH)
            success = await checker.initialize_client()
            if not success:
                logger.warning("Phone checking disabled - requires manual setup")
                checker = None
        else:
            logger.info("Phone checking disabled - API credentials not configured")
    else:
        logger.info("Phone checking disabled for deployment (enable with ENABLE_PHONE_CHECKING=true)")
    
    # Create application
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(handle_admin_callback))
    
    # Initialize and start the bot (Simple polling like working bot)
    logger.info("ЁЯдЦ Telegram Number Checker Bot starting...")
    try:
        # Start the bot with polling (like successful bot)
        await application.initialize()
        await application.start()
        await application.updater.start_polling()
        
        logger.info("тЬЕ Telegram Number Checker Bot is running!")
        
        # Keep running until interrupted
        try:
            while True:
                await asyncio.sleep(1)
        except KeyboardInterrupt:
            logger.info("Bot stopped by user")
        
    except Exception as e:
        logger.error(f"Error running bot: {e}")
    finally:
        # Cleanup
        logger.info("Shutting down bot...")
        try:
            await application.updater.stop()
            await application.stop()
        except:
            pass
        
        if checker:
            try:
                await checker.client.disconnect()
            except:
                pass

if __name__ == "__main__":
    import asyncio
    print("ЁЯдЦ Starting Telegram Number Checker Bot...")
    asyncio.run(main())

def run_bot():
    """Run the bot with proper event loop handling"""
    try:
        # Check if there's already a running event loop
        try:
            loop = asyncio.get_running_loop()
            logger.warning("Event loop already running, creating new thread")
            import threading
            import concurrent.futures
            
            def run_in_thread():
                new_loop = asyncio.new_event_loop()
                asyncio.set_event_loop(new_loop)
                try:
                    new_loop.run_until_complete(main())
                finally:
                    new_loop.close()
            
            thread = threading.Thread(target=run_in_thread)
            thread.start()
            thread.join()
            
        except RuntimeError:
            # No event loop running, we can use asyncio.run
            asyncio.run(main())
            
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.error(f"Error: {e}")

if __name__ == '__main__':
    run_bot()
